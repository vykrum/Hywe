module CodeNode

open System
open System.Collections.Generic
open Bolero
open Bolero.Html
open NodeCode

// Match syntax generated by the graph input
let preprocessCode (code: string) : string =
    // Split into parts and trim
    let lines =
        code.Split([|','|], StringSplitOptions.RemoveEmptyEntries)
        |> Array.map (fun item -> item.Trim('(', ')', ' '))

    // Step 1: Extract all top-level integers > 1
    let topLevelInts =
        lines
        |> Array.choose (fun line ->
            let parts = line.Split('/')
            if parts.Length = 3 then
                let path = parts.[0]
                let firstSeg = path.Split('.').[0]
                match Int32.TryParse firstSeg with
                | true, n when n > 1 -> Some n
                | _ -> None
            else None
        )
        |> Set.ofArray

    // Step 2: Create mapping dictionary: 2 -> 1.0, 3 -> 1.0.0, etc.
    let intMap =
        topLevelInts
        |> Seq.map (fun n -> 
            let mapped = String.Join(".", Array.create (n - 1) "0")
            (n.ToString(), if mapped = "" then "1" else "1." + mapped))
        |> dict

    // Step 3: Replace path prefixes based on mapping
    let updatedLines =
        lines
        |> Array.map (fun line ->
            let parts = line.Split('/')
            if parts.Length = 3 then
                let path = parts.[0]
                let segments = path.Split('.')
                let first = segments.[0]
                if intMap.ContainsKey(first) then
                    let newPath = 
                        if segments.Length > 1 then
                            String.Join(".", Array.append [| intMap.[first] |] segments.[1..])
                        else
                            intMap.[first]
                    $"({newPath}/{parts.[1]}/{parts.[2]})"
                else
                    $"({line})"
            else
                $"({line})"
        )

    // Return reconstructed string
    String.Join(",", updatedLines)

// Parses the processed input into a tree structure
let parseOutput (code: string) : TreeNode =
    let entries =
        code.Split([|','|], StringSplitOptions.RemoveEmptyEntries)
        |> Array.choose (fun item ->
            let trimmed = item.Trim('(', ')', ' ')
            let parts = trimmed.Split('/')
            if parts.Length = 3 then
                let path = parts.[0]
                if path.StartsWith("0") then
                    None
                else
                    let weight = parts.[1]
                    let name = parts.[2]
                    Some (path, weight, name)
            else
                None
        )

    if not (entries |> Array.exists (fun (path, _, _) -> path = "1")) then
        failwith "Invalid Hywe Syntax"

    let nodeMap =
        entries
        |> Seq.map (fun (path, weight, name) ->
            path, {
                Id = Guid.NewGuid()
                Name = name
                Weight = weight
                X = 0.0
                Y = 0.0
                Children = []
            }
        )
        |> dict
        |> System.Collections.Generic.Dictionary

    let byDepth =
        entries
        |> Array.groupBy (fun (path, _, _) -> path.Split('.').Length)
        |> Array.sortByDescending fst

    for (_, group) in byDepth do
        for (path, _, _) in group do
            if path.Contains '.' then
                let parentPath = path.Substring(0, path.LastIndexOf('.'))
                if nodeMap.ContainsKey(parentPath) && nodeMap.ContainsKey(path) then
                    let parent = nodeMap.[parentPath]
                    let child = nodeMap.[path]
                    nodeMap.[parentPath] <- { parent with Children = parent.Children @ [child] }

    nodeMap.["1"]

let computeCanvasBounds (nodes: TreeNode list) : float * float =
    let margin = 50.0
    let maxX = nodes |> List.map (fun n -> n.X) |> List.max
    let maxY = nodes |> List.map (fun n -> n.Y) |> List.max
    maxX + margin, maxY + margin

let rec flattenTree (node: TreeNode) : TreeNode list =
    node :: (node.Children |> List.collect flattenTree)

let rec layoutTree (node: TreeNode) (depth: int) (xRef: float ref) : TreeNode =
    let horizontalSpacing = 80.0
    let verticalSpacing = 55.0

    let laidOutChildren = node.Children |> List.map (fun child -> layoutTree child (depth + 1) xRef)

    let x =
        if laidOutChildren.IsEmpty then
            let x = !xRef
            xRef := x + horizontalSpacing
            x
        else
            laidOutChildren |> List.averageBy (fun n -> n.X)

    {
        node with
            X = x
            Y = float depth * verticalSpacing
            Children = laidOutChildren
    }

type svLin = Template<""" <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${st}" />""">
type svRct = Template<""" <rect x="${x}" y="${y}" width="${w}" height="${h}" rx="${rx}" ry="${ry}" fill="${fl}" stroke="${st}" />""">
type svTxt = Template<""" <text x="${x}" y="${y}" font-size="${sz}" text-anchor="${ta}" fill="${fl}">${nm}</text>""">

let viewTreeSvg (root: TreeNode) : Node =
    let root = layoutTree root 0 (ref 100.0)
    let nodes = flattenTree root

    let margin = 50.0
    let minX = nodes |> List.map (fun n -> n.X) |> List.min
    let maxX = nodes |> List.map (fun n -> n.X) |> List.max
    let minY = nodes |> List.map (fun n -> n.Y) |> List.min
    let maxY = nodes |> List.map (fun n -> n.Y) |> List.max

    let vbX = minX - margin
    let vbY = minY - margin
    let vbW = maxX - minX + 2.0 * margin
    let vbH = maxY - minY + 2.0 * margin
    let viewBoxStr = sprintf "%f %f %f %f" vbX vbY vbW vbH

    let rec renderConnections (parent: TreeNode) : Node list =
        parent.Children
        |> List.collect (fun child ->
            [
                svLin()
                    .x1(string parent.X)
                    .y1(string parent.Y)
                    .x2(string child.X)
                    .y2(string child.Y)
                    .st("#cccccc")
                    .Elt()
            ] @ renderConnections child
        )

    let renderNode (node: TreeNode) : Node list =
        [
            svRct()
                .x(string (node.X - 30.0))
                .y(string (node.Y - 20.0))
                .w("60")
                .h("30")
                .rx("6")
                .ry("6")
                .fl("white")
                .st("#aaaaaa")
                .Elt()

            svTxt()
                .x(string node.X)
                .y(string (node.Y - 6.5))
                .ta("middle")
                .sz("11")
                .fl("#333333")
                .nm(node.Name)
                .Elt()

            svTxt()
                .x(string node.X)
                .y(string (node.Y + 4.5))
                .ta("middle")
                .sz("10")
                .fl("#777777")
                .nm(node.Weight)
                .Elt()
        ]

    svg {
        yield attr.width "100%"
        yield attr.height "100%"
        yield "viewBox" => viewBoxStr
        yield attr.style "max-width: 100%; height: auto; display: block; margin: auto;"

        for conn in renderConnections root do
            yield conn

        for node in nodes do
            for el in renderNode node do
                yield el
    }

let viewCodeGraphFromString (code: string) : Node =
    try
        let processed = preprocessCode code
        let root = parseOutput processed
        
        div {
            attr.style "margin-top: 20px; font-family: monospace; font-size: 14px; color: #444;"
            viewTreeSvg root
            $"Processed code: {processed}"
        }
    with ex ->
        div {
            attr.style "color:red"
            text $"Error: {ex.Message}"
        }
